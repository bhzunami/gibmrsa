\newpage
\section{RSA Ver- und Entschlüsselung}
Der Name RSA setzt sich aus den Anfangsbuchstaben der Nachnamen der Entwickler zusammen. Das RSA Verfahren wird auch heute noch oft eingesetzt. Das Verfahren gilt ab einer bestimmten Schlüssellänge als sehr sicher. Es gibt verschiedenste Angriffsmöglichkeiten, die wir weiter unten vorstellen, diese führen jedoch in einem vernünftigen Zeitraum nicht zu einem korrekten Ergebniss.\\
Das RSA Verfahren ist verwandt mit dem Rabin-Kryptosystem, das auch auf Primzahlen beruht. %Verweis%

\subsection{Der Schlüssel}
Dieses Kapitel wurde mit Hilfe des Buches \textit{RSA and Public-Key Cryptography} erarbeitet.\\[2ex]
%
Für eine sichere Verschlüsslung braucht es einen langen und möglichst zufällig ausgewählten Schlüssel. Der Schlüssel spielt also eine zentrale und wichtige Rolle. Dazu muss er so komplex sein, dass man ihn nicht erraten, oder durch Ausprobieren entdecken kann. Um dies zu erreichen, verwendet man Zufallszahlen.
%
\subsubsection{Zufallszahlen generieren}
Zufallszahlen sind ein sehr komplexes Thema. Um sichere Zufallszahlen zu generieren, haben spezialisierte Firmen Ein Zufallszahlengenerator (eng. \textit{random number generator} RNG) entwickelt. Diese messen den radioaktiven Zerfall oder beobachteten die atmosphärischen Bedingungen in der Umgebung. Die Zahlen, die der RNG auswertet, nennt man \textbf{Seed-Zahlen}. Mit den gewonnen Seed-Zahlen kann man jetzt einen Algorithums füttern, der eine Zahl oder eine Zahlenfolge zurückgibt.\\
Speziell bei der RSA-Verschlüsselung muss man die Zahl/en überprüfen ob es eine Primzahl ist. Zur Überprüfung gibt es Verfahren, die wir hier nicht weiter erleutern werden. Mehr Informationen dazu fnden sie im Buch \textit{RSA and Public-Key Cryptography - Kapitel 4}.\\
%
Für die meisten Benutzer sind solche Generatoren viel zu aufwendig und teuer. Deshalb entwickelten Computerhersteller ein Pseudozufallszahlengenerator (eng. \textit{pseudo random number generator} PRNG). Der PRNG erstellt die Seed-Zahlen zum Beispiel aus der momentanen CPU Auslastung oder anderen, nicht vorhersehbaren Ereignissen.\\
Ob die Zufallszahlen geeignet sind oder nicht, ist schwierig zu sagen. Denn wie will man eine Folge von Zufallszahlen beurteilen?\\
Das Einzige, was man errechnen kann, ist die Entropie\footnote{Die Entropie beschreibt das Mass der Unordnung.}. Je höher die Entropie, desto unwahrscheinlicher ist es, dass diese Zahlenfolge ein zweites Mal vorkommt.
%Buch RSA and Public-Key Seite 61 
\subsubsection{RSA-Schlüssel generieren}
Für eine RSA-Verschlüsselung brauchen wir zwei Schlüssel, die voneinander abhängig sind. Einen privaten und einen öffentlichen Key. Im nächsten Abschnitt wird erläutert, wie man dieses Schlüsselpaar ermittelt.% zwei Schlüsser zeugen kann.
%
\paragraph{Public-Key erstellen}\label{sec:public_key}
Als erstes brauchen wir zwei Primzahlen p und q die weit voneinander weg liegen. Je grösser sie sind, desto besser und sicherer wird das Schlüsselpaar. Wie man solche Primzahlen erstellt, möchten wir hier nicht erläutern. Es gibt Methoden, bei denen man mit grosser Wahrscheinlichkeit eine Primzahl generieren kann. Man muss die Zahl nachher immer überprüfen.\\
Sind beide Primzahlen gefunden, errechnen wir uns das RSA-Modul N: %, auch RSA-Modul genannt.
%
\begin{equation}
  N = p \cdot q
  \label{eqn:rsa_modul}
\end{equation}
%
Als nächstes rechnen wir mit der Eulerschen Funktion [\ref{eqn:eulersche_func}] $\varphi$(N) von p und q aus.\\
Zu der Zahl $\varphi$(N) nehmen wir eine weitere zufällige, zu $\varphi(N)$ \textbf{teilerfremde} Zahl e, die den RSA Verschlüsselungs-Exponent bildet.\\
Die Zahlen N und e bilden zusammen den öffentlichen Schlüssel.
\paragraph{Private-Key erstellen}
Wir haben vorher bei der Erstellung des public Keys die Zahlen für N und e berechnet. Als nächstes wird aus diesen beiden Zahlen d errechnet. d wird als Enschlüsselungs-Exponent im privaten Schlüssel benötigt.\\
Mit dem erweiterten Euklidischen Algorithmus [\ref{eqn:erw_euklid_algo}] und der Modularen Inverse wird d berechnet.\\
%
% TODO: Auf modulare inverse hinweisen!!!!!
%\begin{flalign*}
%  e * d \bmod(\varphi(n)) = 1\\
%  e * d \equiv 1 (\bmod \varphi(N) )
%\end{flalign*}
%
%stimmt. \\
Nachdem d berechnet ist, besitzt man seinen privaten Schlüssel mit den Zahlen d und N.
