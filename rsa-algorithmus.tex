\part{Der RSA-Algorithmus}
\input{./mathematische_verfahren.tex}

\input{./schluessel.tex}
\section{RSA Verschlüsselung}
Die RSA Verschlüsselung wurde 1977 von Ronald L. Riverst, Adi Shamir und Leonard Adleman entwickelt. Der Name RSA setzt sich aus den Anfangsbuchstaben der Nachnamen der Entwickler zusammen. Es handelt sich um ein aymetrisches Verfahren. (Siehe Kapitel moderne Kryptographie) %Verweis%
Das RSA Verfahren wird auch heute noch oft eingesetzt. Das Verfahren gilt bei einer bestimmten Schlüssellänge als sicher. Es gibt verschiedenste Angriffsmöglichkeiten, diese führen jedoch nicht in einem vernünftigen Zeitraum zu Ergebnissen. Das Verfahren wird zur Signierung und zur Verschlüsselung verwendet. (Siehe Anwendung) %Verweis%

\subsection{Formel Verschlüsselung}
Wenn der Schlüssel erstellt wurde kann ein Text einfach verschlüsselt werden. Dazu dient folgende Formel:
$ C \equiv m^e  \bmod N $\\
C steht für Cipher und bezeichnet den Geheimtext. Dieser ist abhängig von der Nachricht m, dem öffentlichen Schlüssel e und dem RSA-Modul N.

\section{RSA Entschlüsselung}
Die RSA Entschlüsselung ist ohne den Geheimschlüssel zu wissen nicht möglich. Da die Sicherheit von diesem Geheimschlüssel abhängt, gilt es diesen möglichst lang zu wählen und geheim zu halten. Aktuell gilt eine Schlüssellänge von 2048 Bit als sicher. Als Dezimalzahl ausgedrückt, ist dies eine Zahl von $ 3,2 * 10^{616} $
Die Angriffe auf die RSA Verschlüsselung zielen darauf ab, den Geheimschlüssel zu ermitteln. Das Problem dabei ist die Primfaktoren Zerlegung von grossen Zahlen. Mehr dazu im Kapitel Angriffe %Verweis%

\subsection{Formel Entschlüsselung}
Die Entschlüsselung der Nachricht wird mit folgender Formel realisiert
$ m \equiv C^d \bmod N $ \\
Der Klartext m hängt in diesem Fall vom verschlüsselten Text C, dem privaten Schlüssel d und dem RSA-Modul N ab. 
%
\section{Mathematisches Beweis der Funktionsweise}
Bisher nahmen wir an, dass der RSA-Algorithmus korrekt arbeitet. Diese Annahme möchten wir nun beweisen. Der Algorithmus arbeitet korrekt, wenn die Verschlüsselung und Entschlüsselung wieder das gleiche ergibt. Dies darf nur mit dem zugehörigen privaten Schlüssel möglich sein.

\subsection{Verschlüsselung und Entschlüsselung gleichsetzen}
Für den Beweis benötigen wir die ursprünglichen Formeln zu Verschlüsselung und Entschlüsselung. Diese lauten:
%Damit wir die korrekte Funktionsweise beweisen können setzen wir die Entschlüsselung und Verschlüsselung gleich. Dazu dienen uns die ursprünglichen Formeln zur Verschlüsselung und Entschlüsselung \\%

\begin{align}
  C = m^e mod N \\
  m = C^d mod N
\end{align}
Da in beiden Formeln die Ursprungsnachricht m und die verschlüsselte Nachricht C vorkommen, können wir diese Formeln gleichsetzen. Dazu lösen wir die Entschlüsselungsformel nach C auf:
\begin{align}
  m = C^d mod N \\
  m + k * N = C^d \\
  \sqrt[d]{m+k*N} = C \\
  C = \sqrt[d]{m+k*N}
\end{align}
Wir setzen nun die beiden Formeln gleich, so das nur noch die Ursprungsnachricht m in der Gleichung vorhanden ist:
\begin{align}
  m^e mod N = \sqrt[d]{m+k*N}\\
  m^{e*d} mod N = m + k * N\\
  m^{e*d} mod N = m
\end{align}
Die Formel $ m^{e*d} mod N = m + k * N $ kann gekürzt werden, da k in jedem Fall 0 sein muss. Dies liegt daran, dass wir auf der linken Seite mit Modulo N den Rest ausgeben. Der Rest kann 1 bis N-1 gross sein. Da m schon einen Wert hat muss k in diesem Fall 0 sein. \\
Somit möchten wir beweisen, dass die Verschlüsselung (hoch e) und nachherige Entschlüsselung (hoch p) wieder die ursprüngliche Nachricht ergibt:
$ m^{e*d} mod N = m $

\subsection{Grundlagen zur Erklärung}
Für den Beweis benötigen wir vorherige Kenntnisse und bestimmte Sätze. Diese möchten wir hier nochmals kurz in Erinnerung rufen.\\ 
Das RSA-Modul N wird aus den ausgewählten Primzahlen p und q erstellt.
\begin{align}
  N = p * q
\end{align}

e wurde teilerfremd zu $ \varphi(n) $ gewählt. 
$ \varphi(n) = (p-1)*(q-1) $

Zusätzlich wurde d so gewählt, dass folgendes zählt:
\begin{align}
 e * d + k * \varphi(N) = 1 = ggT(e,\varphi(N))
\end{align}

Für den Beweis müssen wir ausschweifen auf den Satz von Euler Fermat. Dieser bildet die Grundlage zur RSA-Verschlüsselung. Er lautet wie folgt:
\begin{align}
	a^{\varphi(n)} \equiv 1\,(\mathrm{mod}\,n)
\end{align}
Da wir mit Primzahlen arbeiten, kann dieser Satz auch anders ausgedrückt werden. $ \varphi(n) $ gibt alle teilerfremden Zahlen zu n an. Da n durch zwei Primzahlen gebildet wurde, gibt es $ (p-1)*(q-1) $ teilerfremde Zahlen. 

\subsection{Beweis der Funktionsweise}
Die Gleichsetzung der Entschlüsselung und Verschlüsselung dient uns als Grundlage des Beweises:
\begin{align}   
 m^{e*d} mod N = m
\end{align}
%
Wir nehmen nun die Formel der multiplikativen Inverse um $ e*d $ anders auszudrücken. Diese lösen wir gleich nach $ e*d $ auf:\\
$ e \cdot d \equiv 1 \bmod{\varphi(N)} $
% \begin{align}
%e \cdot d \equiv 1 \bmod{\varphi(N)} 
 % Kuster fragen wie das gemeint ist?
%   Wegen e*d=1 (mod j(n)) gibt es ein k Î N mit e*d=k* j(n)+1
%\end{align}

Nun ersetzen wir in unserer Aussage $ e*d $ durch $ k* \varphi(n)+1 $
\begin{center}
$ m^{ k* \varphi(n) +1} = m $ \\
$ m^{k* \varphi(n)} * m = m $ \\
$ { m^{ \varphi(n) }} ^k * m = m $ \\
\end{center}
% \begin{align}
%   m^{k*\varphi(n)+1} = m
%   m^{k*\varphi(n)} * m = m
%   m^{\varphi(n)}^k * m = m
% \end{align}

Durch den Satz von Fermat wissen wir dass $ \varphi(n) $ 1 sein muss:
\begin{align}
  m^{(p-1)} = 1 \bmod p
  m^{(p-1)*(q-1)} = 1^{q-1} \bmod p*q
  m^{(p-1)*(q-1)} = 1 \bmod p*q
  m^{\varphi(N)} = 1 \bmod N
\end{align}
1. Eine Zahl hoch die Anzahl der Teilerfremden Zahlen bei einer Primzahl ergibt 1 mod die Zahl
2. Wir rechnen beide Seiten hoch (q-1), was in unserem Fall die zweite Primzahl ist % a = b mod m ist wie a^k = b^k mod m
3. 1 hoch eine Zahl ergibt immer 1

Schlussfolgerung daraus:
% \begin{align}
%	m^{\varphi(n)}^k * m = m
%	1(mod N)^k * m = m
%	1^k * m = m
%	1 * m = m
% \end{align}
 
 Der Algorithmus funktioniert korrekt. 


Für den Beweis brauchen wir die Primzahlen p und q. Aus diesem wurde das RSA-Modul N gebildet
$ n = p * q $

Zusätzlich wurde und e und d so gewählt, dass folgendes zählt:
$ e * d \bmod \varphi(n) = 1 $

Lösen wir dies nach e*d kommt k hinzu:
$ e * d = 1 + k * \varphi(n) $
Die Modulo-Operation ergibt den Rest, welcher bei der Division durch eine Zahl anfällt. In unserem Fall ist der Rest immer 1.

Nun können wir e * d einsetzen:
$ m^e*d = m^k*\varphi(n)+1 $

% Alt 2 %

Die allgemeine Formel zur Entschlüsselung ist:
$ m \equiv C^d \bmod N $

Setzen wir nun für den verschlüsselten Text die verschlüsselte Form von K ein muss dies immer noch K ergeben.
$ m \equiv (m^e)^d \bmod N $

$ m \equiv m^{e*d} \bmod N $
Wenn diese Bedingung erfüllt ist, arbeitet der Algorithmus korrekt.

Um die Richtigkeit zu beweisen kommen wir auf die Anfangszahlen p und q zurück, welche das RSA-Modul N bilden. Es handelt sich um Primzahlen. Wir zeigen das Vorgehen anhand von p:
$ 0 \equiv m^{e*d} \bmod p - K \bmod p $

$ 0 \equiv (m^e*d-m) \bmod p $

Da wir e und d so gewählt haben, dass 
$ ed \bmod \varphi(n) = 1 $ 
%Verweis% 


\section{Beispiel}
\subsection{Einfaches Zahlenbeispiel}
Ein einfaches Beispiel für den RSA-Algorithmus
\subsubsection{Schlüssel-Paar erstellen}
Ein einfaches Zahlenbeispiel. Wir suchen uns zwei kleine Primzahlen.\\
$ p = 13 $ \\
$ q = 19 $ \\
Somit ist N das ja aus q * p gebildet wird 247. Und $ \varphi(N) $ = 216.\\
$ N = 13 * 19 = 247 $ \\
$ \varphi(N) = (13 - 1) * (19 - 1) = 216 $ \\
Zu $ \varphi(N) $ suchen wir uns jetzt noch eine zweite Zahl e, die teilerfremd zu $ \varphi(N) $ ist, sprich den ggT(N,e) = 1. Am Besten man verwendet eine weitere Primzahl. Wir nehmen für e die Primzahl 23.
$ e = 23 $\\
ggT(23,216) ausrechnen:\\
$ 216 = 9 * 23 + 9 $\\
$  23 = 2 *  9 + 5 $\\
$   9 = 1 *  5 + 4 $\\
$   5 = 1 *  4 + 1 $\\
Erweiterter Euklidischer Algorithmus anwenden um auf die Formel:
$e * d + k * N = 1 = ggt(23,216) $\\
$1 = 5 - 1 * 4 = 5 - 1 *(9 - 1 * 5) = 5 - 1*9 + 1 * 5 = 2*5 - 1*9$\\
$1 = 2*5 - 1*9 = 2 *(23 - 2 * 9) - 1*9 = 2*23 - 4*9 - 1*9 = 2*23 - 5*9$\\
$1 = 2*23 - 5*9=2*23 - 5 *(216 - 9 * 23) = 2*23 - 5*216 +45*23 = 47*23 - 5*216 $\\
Somit haben wir die Formel
$ 23 * 47 + -(5) * 216 = 1 = ggT(23,216) $
$ d = 47 $\\
$ k = -5 $\\
Jetzt haben wir alle nötigen Zahlen die wir für eine Verschlüsselung sowie Entschlüsselung benötigen.
\subsubsection{Verschlüsseln}
Da man Text nicht verschlüsseln kann, braucht man für den Text Zahlen. Wir nehmen jetzt zur Vereinfachung eine Zahl.\\
$ m = 15 $ \\
$ 15^{23} \bmod 247 = 59$ \\
Die Zahl 15 verschlüsselt mit unserem öffentlichen Schlüssel (23,247) ergibt die Zahl 59.
\subsubsection{Entschlüsseln}
Um zu überprüfen ob unserer privater Schlüssel auch wirklich funktioniert, entschlüsseln wir die Zahl 59 mit unserem privaten Schlüssel.\\
$ c = 59 $ \\
$ 59^{47} \bmod 247 = 15$ \\
Somit sehen wir, dass unser kleines Beispiel funktioniert hat.
%\subsection{Komplexeres Zahlenbeispiel}
\subsection{Beispiel an einem Text}
Wir nehmen für unser Beispiel an unserem Text das gleiche Schlüssel Paar wie aus unserem obigen Beispiel.
$ N = 247 $\\
$ e = 23 $\\
$ d = 47 $\\
Wir müssen nur noch ein Verfahren wählen, wie wir einen Buchstaben in eine Zahl umwandeln. Für das gibt es \textit{ASCII} Tabellen, die für jedes Zeichen, eine Zahl darstellen.\\
Wir würden gerne das Wort \textit{Hello World} verschlüsseln. Als erstes müssen wir unseren Text in Zahlen umwandeln. Dazu verwenden wir die Dezimalschreibweise.\\
\textit{Hello World} würde in dieser Schreibweise \textit{721011081081113287111114108100} heissen. Jetzt ist das natürlich eine viel zu hohe Zahl. Deshalb wird sie immer nach zwei Ziffern getrennt. Unser Text zum verschlüsseln würde dann so aussehen \textit{72 10 11 08 10 81 11 32 87 11 11 14 10 81 00}. Jetzt können wir uns ans Verschlüsseln machen. \\
$ 72^{23} \bmod 247 = 002 $ \\
$ 10^{23} \bmod 247 = 212 $ \\
$ 11^{23} \bmod 247 = 045 $ \\
$ 08^{23} \bmod 247 = 031 $ \\
$ 10^{23} \bmod 247 = 212 $ \\
$ 81^{23} \bmod 247 = 009 $ \\
$ 11^{23} \bmod 247 = 045 $ \\
$ 32^{23} \bmod 247 = 128 $ \\
$ 87^{23} \bmod 247 = 159 $ \\
$ 11^{23} \bmod 247 = 045 $ \\
$ 11^{23} \bmod 247 = 045 $ \\
$ 14^{23} \bmod 247 = 105 $ \\
$ 10^{23} \bmod 247 = 212 $ \\
$ 81^{23} \bmod 247 = 009 $ \\
$ 00^{23} \bmod 247 = 000 $ \\
Somit würde der Text verschlüsselt \textit{002212045031212009045128159045045105212009000} lauten.
Um zu testen ob es stimmt verschlüsseln wir unser Text. Auch hier wieder die Zahlen in Unterteilen.
$ 002^{47} \bmod 247 = 72 $ \\
$ 212^{47} \bmod 247 = 10 $ \\
$ 045^{47} \bmod 247 = 11 $ \\
$ 031^{47} \bmod 247 = 08 $ \\
$ 212^{47} \bmod 247 = 10 $ \\
$ 009^{47} \bmod 247 = 81 $ \\
$ 045^{47} \bmod 247 = 11 $ \\
$ 128^{47} \bmod 247 = 32 $ \\
$ 159^{47} \bmod 247 = 87 $ \\
$ 045^{47} \bmod 247 = 11 $ \\
$ 045^{47} \bmod 247 = 11 $ \\
$ 105^{47} \bmod 247 = 14 $ \\
$ 212^{47} \bmod 247 = 10 $ \\
$ 009^{47} \bmod 247 = 81 $ \\
$ 000^{47} \bmod 247 = 00 $ \\
Das 000 ist ein bisschen problematisch, denn eigentlich gibt es nur 0 aber da wir ja auf zwei Stellen kommen müssen, wissen wir dass es 00 sein mus. Wie wir sehen haben wir unseren Text \textit{721011081081113287111114108100}  wieder.
\section{Anwendung}
\subsection{SSH - Secure Shell}
