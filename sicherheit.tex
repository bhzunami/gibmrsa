\part{Sicherheit}
\section{Allgemeines}
%Referenz:http://netlab.cs.ucla.edu/wiki/files/shannon1949.pdf
%Bzw. Wikipedia: http://de.wikipedia.org/wiki/Beweisbare_Sicherheit
In der Kryptologie spricht man von einer beweisbaren Sicherheit, welche eigentlich keine ist. Um die Sicherheit zu beweisen werden verschiedene Annahmen getroffen. Dies bezieht sich oft auf die zur Verfügung stehenden Rechenleistung und den entsprechenden Zeitaufwand. Da die Rechenleistung zunimmt werden die Schlüssel mit der Zeit länger. \\
Der Mathematische Beweis ist jeweils eine Reduktion des Problems. Es wird dabei angenommen das es schwierig ist z. B. zwei Primzahlen wieder zu faktorisieren. Dabei ist aktuell nur keine effektive Möglichkeit gefunden worden, das Problem zu lösen. Es ist jedoch nicht bewiesen, ob es unmöglich oder gar schwierig ist.

%#######################################################
% Primzahlen und Faktorisierungsproblem
%#######################################################
\section{Faktorisierungsproblem}
\subsection{Schwierigkeit}
Die Sicherheit der RSA-Verschlüsselung beruht auf dem Faktorisierungsproblem. Es wurde bisher noch keine effektive Methode gefunden um grosse Zahlen in ihre Primzahlen zu faktorisieren. Besonders schwer ist es wenn die Zahl aus zwei grossen Primzahlen besteht. 
Ein kleines Beispiel:
Die Faktorisierung von 14 in die beiden Primzahlen 2 und 7 fällt nicht sehr schwer\\
Die Faktorisierung von 30518 ist ebenfalls einfach, da nur eine Primzahl gross gewählt wurde. Es handelt sich um 2 und 15259. \\
Die Faktorisierung von 771'151 ist schon wesentlich schwerer. Obwohl es die kleinen Zahlen 823 und 937 sind. Das RSA-Modul N wird aus zwei Primzahlen mit einer Länge von 2048 Bit (617 Dezimalstellen) erstellt. Wir sehen hier das die Sicherheit von RSA wesentlich von der gewählten Schlüssellänge abhängt. Aus diesem RSA Modul wieder die zwei Primzahlen zu finden kann aktuell nicht effizient bewerkstelligt werden.
%
\section{Angriffe auf die Implementierung des RSA-Algorithmus}
Das Faktorisierungsproblem selbst konnte bisher nicht gelöst werden. Jedoch gibt es verschiedene Ansätze um bei bestimmten Konstellationen das Problem effizient zu lösen. 
Bei diesen Angriffen wurden die Primzahlen p und q falsch gewählt.
Falls die Primzahlen p und q zu nahe beieinander liegen, kann das Faktorisierungsproblem mit versuchen in einem bestimmten Zahlenspektrum überlistet werden. Das RSA-Modul N ist 753'343. Von dieser Zahl ziehen wir die Wurzel und erhalten $ \sqrt{753323} \approx 867.95 $. Wir können  ein Spektrum von +-100 bestimmen und erhalten 768 - 968. Die Zahl 753'343 versuchen wir durch die einzelnen Zahlen des Spektrums zu teilen. Bei der Zahl 859 erhalten wir die Zahl 877 und haben somit das Problem gelöst. Wir machen hier kein Primzahlentest da dies zusätzliche Rechenleistung benötigt und somit die Effizienz verringern würde. Daraus ist ersichtlich das die Primzahlen nicht nahe beieinander liegen dürfen.%
%
\subsection{Side Channel Attack}
Eine side channel attack ist einen Angriff auf die Implementierung des Verschlüsselungssystem. Es greift als nicht den RSA-Algorithmus direkt an.
Dieses Verfahren wurde 1996 von Herrn Paul C. Kocher, einem amerikanischen Kryptologen vorgestellt.
Im wesentlichen geht es bei einer side channel attacke darum, das kryptographische Gerät beim Ausführen ders Algorithmus zu beobachten und Korrelationen. bzw beziehungen feststellt zwischen den beobachteten Daten und dem Schlüssel zu finden.
Man beobachtet zum Beispiel die Laufzeit des Algorithmus, den Energieverbrauch des Prozessors während der Berechunung oder der elektromagnetische Ausstrahlung
%
% http://www.usna.edu/Users/math/wdj/book/node45.html
\subsubsection{Timing Attack}
Die Timing Attack ist eine side channel attack (Seitenkanalattacke). 
Bei ihr mistt man die Rechenzeit, die der Computer bzw. die CPU für die verschieden implementierungen des RSA-Verfahrens braucht. Die meisten Verschlüsselugns implementationen sind so geschrieben, dass sie möglichst schnell rechenen, da man grosse Primzahlen hat. Bei einer CPU, braucht jede Recheneinheit die exakt gleiche Zeit. Durch diese Analyse kann man den Schlüssel nach rekonstruieren. Das geht 
%
Verschiedene Berechnungen werden durchgeführt und ihre Zeiten notiert. Aus dieser Analyse werden Entschidungskriterin aufgestellt, die nur eine mögliche Lösung möglich ist. Diese Lösung hängt von dem gewählten Schlüssel ab.
%
Um sich von solchen Angriffen zu wehren, baut man in die Implementierung geeisse Berechnungen ein, damit jede Berechnung gleich lang dauert. So ist es nicht mehr möglich verschiedene Zeiten festzu stellen.
%
Diese Angriffe sind besonders bei Smart Cards effektiv, da man die Zeit sehr genau messen kann.
%
\subsection{Exponent Attack}
Bei der Exponent Attack, geht man davon aus, dass der private Schlüssel also d klein gewählt wurde. Zur veranschaulichung nehmen wir d = 3.
Die Nachricht m muss kleiner sein als N. Die entschüsselung würde dann so a
\section{Ausblick in die Zukunft}
